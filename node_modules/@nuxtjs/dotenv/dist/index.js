'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = require('fs');
var fs__default = _interopDefault(fs);
var path = require('path');
var path__default = _interopDefault(path);

/* @flow */
/*::

type DotenvParseOptions = {
  debug?: boolean
}

// keys and values from src
type DotenvParseOutput = { [string]: string }

type DotenvConfigOptions = {
  path?: string, // path to .env file
  encoding?: string, // encoding of .env file
  debug?: string // turn on logging for debugging purposes
}

type DotenvConfigOutput = {
  parsed?: DotenvParseOutput,
  error?: Error
}

*/




function log (message /*: string */) {
  console.log(`[dotenv][DEBUG] ${message}`);
}

// Parses src into an Object
function parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {
  const debug = Boolean(options && options.debug);
  const obj = {};

  // convert Buffers before splitting into lines and processing
  src.toString().split('\n').forEach(function (line, idx) {
    // matching "KEY' and 'VAL' in 'KEY=VAL'
    const keyValueArr = line.match(/^\s*([\w.-]+)\s*=\s*(.*)?\s*$/);
    // matched?
    if (keyValueArr != null) {
      const key = keyValueArr[1];

      // default undefined or missing values to empty string
      let value = keyValueArr[2] || '';

      // expand newlines in quoted values
      const len = value ? value.length : 0;
      if (len > 0 && value.charAt(0) === '"' && value.charAt(len - 1) === '"') {
        value = value.replace(/\\n/gm, '\n');
      }

      // remove any surrounding quotes and extra spaces
      value = value.replace(/(^['"]|['"]$)/g, '').trim();

      obj[key] = value;
    } else if (debug) {
      log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
    }
  });

  return obj
}

var parse_1 = parse;

function DotEnvModule(moduleOptions) {
  var _this = this;

  var defaultOptions = {
    only: [],
    path: this.options.srcDir,
    filename: '.env',
    systemvars: false
  };

  var options = Object.assign({}, defaultOptions, moduleOptions);

  var envFilePath = path.join(options.path, options.filename);
  try {
    fs.accessSync(envFilePath, fs.constants.R_OK);
  } catch (err) {
    // file not found, just return
    return;
  }
  var envConfig = parse_1(fs.readFileSync(envFilePath));

  var isAllowed = function isAllowed(key) {
    return options.only.length === 0 || options.only.indexOf(key) !== -1;
  };

  if (options.systemvars) {
    Object.keys(process.env).map(function (key) {
      if (!key in envConfig) {
        envConfig[key] = process.env[key];
      }
    });
  }

  Object.keys(envConfig).forEach(function (key) {
    if (isAllowed(key)) {
      _this.options.env[key] = _this.options.env[key] || envConfig[key];
    }
  });
}

module.exports = DotEnvModule;
